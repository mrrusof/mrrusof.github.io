Our solution searches for an answer in a set of candidates.

An answer is any longest stack.
Consider the following sequence of boxes.

```
(1, 5) (2, 4) (3, 5) (3, 6)
```

For the given sequence, stacks `(2, 4) (3, 5)`, `(1, 5) (3, 6)`, and `(2, 4) (3, 6)` are the longest stacks.
Each of them is an answer for the given sequence of boxes.


The set of candidates consists of one candidate stack for each given box.
For a given box, the candidate stack is any longest stack in the set of stacks that end with the box.
For example, the set of stacks what end with the box `(3, 6)` consists of stacks `(3, 6)`, `(1, 5) (3, 6)`, and `(2, 4) (3, 6)`.
Thus, we can choose either `(1, 5) (3, 6)` or `(2, 4) (3, 6)` as the candidate stack for box `(3, 6)`.
The following table indicates the set of candidates that our solution computes for the given sequence of boxes.

{% highlight asciidoc %}
 (1, 5) | (2, 4) | (3, 5) | (3, 6)
--------|--------|--------|--------
 (1, 5) | (2, 4) | (2, 4) | (1, 5)
        |        | (3, 5) | (3, 6)
{% endhighlight %}


At least one candidate is an answer for the given sequence of boxes.


We construct candidates from left to right.


We construct candidates from left to right because no candidate to the right fits the box.
For a given box, no candidate to the right fits the box.
The reason is that the boxes are ordered 
For example, for box `(3, 6)`, none of the candidates to the right fits the box because at least one of their dimensions is greater or equal to the corresponding dimension of the box.
There may be candidates to the left that do not fit the given box.
For example, for box `(3, 6)`, candidate `(1, 5) (3, 5)` does not fit the box.

When we receive an unsorted sequence of boxes, we sort the sequence lexicographically before constructing the set of candidates.

When we compare boxes lexicographically or when we check if one fits another, we compare corresponding dimensions from left to right.
For example, when we check if box `(1, 5)` fits box `(3, 6)`, we do comparisons `1 < 3` and `5 < 6`.

Box `(a1, a2, ..., an)` fits box `(b1, b2, ..., bn)` iff `a1 <= a2 <= ... <= an`, `b1 <= b2 <= ... <= bn` and `a1 < b1`, `a2 < b2`, ..., `an < bn`

When we receive boxes with unsorted dimensions, we sort the dimensions before sorting the sequence of boxes.

     


II.  We simplify comparing boxes by sorting their dimensions.
  A. This way each dimension of A is checked against its corresponding dimension of B.
  B. Sorting takes `d log d` for each box.
  C. Sorting takes `n d log d` for all boxes.
III. 
   


II.  You must keep all alternative paths.

     1. Sample input where all paths are independent.
     (1, 2) (1, 3) (1, 4) (1, 5)
III. You cannot do binary search on the paths.
     1.  Not all boxes are comparable by means of `fits`.
     (1, 2) does not fit in (1, 3)
     (1, 3) does not fit in (1, 2)
IV.  

T(n) = T(n - 1) + log n
T(1) = 0

2 ^ 0 = 1
2 ^ 1 = 2
2 ^ 2 = 4
2 ^ 3 = 8
2 ^ 4 = 16

T(3) = T(2) + log n
T(2) = T(1) + log n

T(n) = T(n / 2) + n
T(1) = 0

T(16) = 16 log 16 = 16 * 4 = 
T(8)  = 8 log 8   = 8  * 3 = 24
T(4)  = 4 log 4   = 4  * 2 = 8

T(16) = 2*T(8) + 16 = 48 + 16 = 64 = 16 log 16
T(8)  = 2*T(4) + 8  = 16 + 8  = 24 = 8 log 8
T(4)  = 2*T(2) + 4  = 4  + 4  = 8  = 4 log 4
T(2)  = 2*T(1) + 2  = 0 + 2
T(1)  = 0

f((1, 2) (1, 3) (1, 4) (1, 5)) = (1, 2)
f((1, 2) (2, 3) (1, 4) (1, 5)) = (1, 2) (2, 3)

(1, 2) (1, 3) | (1, 4) (1, 5)

(1, 2) (1, 3) (1, 4) | (1, 5) --> (1, 2) (1, 3) (1, 4) (1, 5)


Either (2, 3) extends the current solution or not.

(1, 2)
---------------- (2, 3)
(1, 2) -> (2, 3)

(2, 2)
---------------- (2, 3)
(2, 2)
(2, 3)
=======
>>>>>>> a81d921ccdfb72d6826961be0a7f0f72a7824643
