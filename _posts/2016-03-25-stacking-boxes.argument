Our solution searches for an answer in a set of candidates.


An answer is any longest stack.
Consider the following sequence of boxes.

```
(1, 5) (2, 4) (3, 5) (3, 6)
```

For the given sequence, stacks `(2, 4) (3, 5)`, `(1, 5) (3, 6)`, and `(2, 4) (3, 6)` are the longest stacks.
Any of the them is an answer for the given sequence of boxes.


The set of candidates consists of one candidate stack for each given box.
For a given box, the candidate stack is any longest stack in the set of stacks that end with the box.
For example, the set of stacks what end with the box `(3, 6)` consists of stacks `(3, 6)`, `(1, 5) (3, 6)`, and `(2, 4) (3, 6)`.
Thus, we can choose either `(1, 5) (3, 6)` or `(2, 4) (3, 6)` as the candidate stack for box `(3, 6)`.
The following table indicates the set of candidates that our solution computes for the given sequence of boxes.

{% highlight asciidoc %}
 (1, 5) | (2, 4) | (3, 5) | (3, 6)
--------|--------|--------|--------
 (1, 5) | (2, 4) | (2, 4) | (1, 5)
        |        | (3, 5) | (3, 6)
{% endhighlight %}


The set of candidates contains at least one answer for the given sequence of boxes.





We construct the candidate stacks from left to right.
For a given box, the candidate is any longest stack that ends with the box.
For example, the stacks that end with box `(3, 6)` are `(1, 5) (3, 6)` and `(2, 4) (3, 6)`.
We pick the `(1, 5) (3, 6)` because it is the first stack that ends with box `(3, 6)`.

The set of stacks that end with a given box consists of one element per each candidate stack to the left that fits the box.
For example, for box `(3, 6)`, stack `(1, 5) (3, 6)` corresponds to candidate `(1, 5)` and stack `(2, 4) (3, 6)` corresponds to candidate `(2, 4)`.
There is no stack for candidate `(1, 5) (3, 5)` because `(3, 5)` does not fit box `(3, 6)`.

Given that the input sequence of boxes is ordered, we do not consider candidates to the right when computing the set of stacks that end with the box, because none fits the box.
For example, for box `(3, 6)`, none of the candidates to the right fits the box because at least one of their dimensions is greater or equal to the corresponding dimension of the box.
There may be candidates to the left that do not fit the given box.
For example, for box `(3, 6)`, candidate `(1, 5) (3, 5)` does not fit the box.

When we receive an unsorted sequence of boxes, we sort the sequence lexicographically before constructing the set of candidates.

Given that dimensions for each box are sorted, when we compare boxes lexicographically or when we check if one fits another, we compare corresponding dimensions from left to right.
For example, when we check if box `(1, 5)` fits box `(3, 6)`, we do comparisons `1 < 3` and `5 < 6`.

Box `(a1, a2, ..., an)` fits box `(b1, b2, ..., bn)` iff `a1 <= a2 <= ... <= an`, `b1 <= b2 <= ... <= bn` and `a1 < b1`, `a2 < b2`, ..., `an < bn`

When we receive boxes with unsorted dimensions, we sort the dimensions before sorting the sequence of boxes.

     


II.  We simplify comparing boxes by sorting their dimensions.
  A. This way each dimension of A is checked against its corresponding dimension of B.
  B. Sorting takes `d log d` for each box.
  C. Sorting takes `n d log d` for all boxes.
III. 
   


II.  You must keep all alternative paths.

     1. Sample input where all paths are independent.
     (1, 2) (1, 3) (1, 4) (1, 5)
III. You cannot do binary search on the paths.
     1.  Not all boxes are comparable by means of `fits`.
     (1, 2) does not fit in (1, 3)
     (1, 3) does not fit in (1, 2)
IV.  

T(n) = T(n - 1) + log n
T(1) = 0

2 ^ 0 = 1
2 ^ 1 = 2
2 ^ 2 = 4
2 ^ 3 = 8
2 ^ 4 = 16

T(3) = T(2) + log n
T(2) = T(1) + log n

T(n) = T(n / 2) + n
T(1) = 0

T(16) = 16 log 16 = 16 * 4 = 
T(8)  = 8 log 8   = 8  * 3 = 24
T(4)  = 4 log 4   = 4  * 2 = 8

T(16) = 2*T(8) + 16 = 48 + 16 = 64 = 16 log 16
T(8)  = 2*T(4) + 8  = 16 + 8  = 24 = 8 log 8
T(4)  = 2*T(2) + 4  = 4  + 4  = 8  = 4 log 4
T(2)  = 2*T(1) + 2  = 0 + 2
T(1)  = 0

f((1, 2) (1, 3) (1, 4) (1, 5)) = (1, 2)
f((1, 2) (2, 3) (1, 4) (1, 5)) = (1, 2) (2, 3)

(1, 2) (1, 3) | (1, 4) (1, 5)

(1, 2) (1, 3) (1, 4) | (1, 5) --> (1, 2) (1, 3) (1, 4) (1, 5)


Either (2, 3) extends the current solution or not.

(1, 2)
---------------- (2, 3)
(1, 2) -> (2, 3)

(2, 2)
---------------- (2, 3)
(2, 2)
(2, 3)
=======
>>>>>>> a81d921ccdfb72d6826961be0a7f0f72a7824643
