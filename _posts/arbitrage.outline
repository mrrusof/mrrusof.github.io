I.   We solve the problem in O(n^4).
II.  We consider all cycles of lenght 1, 2, ..., n in order.
III. We memoize all subproblems.
IV.  Algorithm S is more similar to Slow All Paths Shortest Paths than to Floyd-Warshall.

R: I solved arbitrage 104.
V: Nice, what is it about?
R: The problem is about making a profit by trading currencies.
   You make a profit when you trade an amount of money in one currency for another, and continue trading until you come back to the initial currency.
   Given that we have operational costs, there is the restriction that the profit be greater than 1%.
   Given that trade sequences that are short are easy to understand, we prefer the profitable sequences that are shortest.
   Given that we want to bound our problem, we do not consider sequences longer than the number of currencies available.
V: What is the input?
R: The input is a conversion table, which corresponds to a graph.
   For example, the following conversion table corresponds to the graph in Figure 1.
     | USD         | MXN         | EUR
----------------------------------------------
 USD | 0           | 1.01^(1/2)  | 1.01^(1/2)
 MXN | 1.01^(-1/2) | 0           | 1.01^(1/2)
 EUR | 1.01^(1/2)  | 1.01^(-1/2) | 0
V: So, is this a graph problem?
R: Well, yes.
   You see, each sequence is a path in the graph.
   A solution is a cycle that is profitable and is shortest.
   Consider the problem in Figure 1.
   In that problem, there are 5 cycles of length 2 or 3.
   Consider the cycles and their corresponding benefit.
   1          : USD -> MXN -> USD
   1.01       : USD -> EUR -> USD
   1          : EUR -> MXN -> EUR
   1.01^(3/2) : USD -> MXN -> EUR -> USD
   1.01^(-1/2): USD -> EUR -> MXN -> USD
   Out of the 5 cycles, only the following are profitable.
   - USD -> EUR -> USD
   - USD -> MXN -> EUR -> USD
   Given that the first of those 2 cycles is shortest, that is the only answer.
V: Is there any restriction on the cycle? Like, does it have to be a simple cycle?
R: No, for example the example in the forum.
   TODO: Figure 2
   The cycle 1 2 1 2 1 is profitable and 1 2 1 is not.
   The rate of 1 2 1 is X > 1.
   The rate of 1 2 1 2 1 is Y >= 1.01.
V: Is it the case that when the solution is a compound cycle, the solution is a repetition of the same cycle?
R: Not necessarily, consider this example.
   TODO: Figure 3
V: Nice, how did you approach the problem?
R: I approach the problem by considering all cycles of length 2 before considering any other cycle.
   Then I consider cycles of length 3, then of length 4, and so on.
   The moment I find a cycle that is profitable, I find my answer because there is no shorter cycle that is profitable.
   If I consider all cycles and don't find a profitable cycle, then there is no solution.
V: Makes sense. Just how do you consider cycles of length 2, length 3, and so on in that order? How do you enumerate them?
R: Well, for each length L, I consider each node R.
   For node R, I consider the paths that start in R and have length L.
   Consider example in Figure 1.
   Figure 4 shows the paths of length 2 from each node.
   TODO: Figure 4
   In each of the trees, each leaf that equals the root corresponds to a cycle.
   If none of those cycles is profitable, then I consider paths of length 3 in Figure 5.
   Some of those cycles are repeated, so I do not consider them.
   The rule is that a path is repeated if it visits a node N that is less than the current root R.
   For example, the paths that are highlighted in Figure 5 are repeated.
   When I do not find a profitable cycle of length 2, I repeat the process with length 3.
   Figure 6 shows in yellow the cycles of length 3 and in gray the paths I do not consider.
   TODO: Figure 6
   I do not enumerate all these cycles because there are too many.
   Even for Kn, n <= 20, the number of cycles may be very large.
   Consider the number of cycles.
   TODO: Table
 K  | Cycle count
------------------
 4  | 42
 ...
 10 | 582,508,305
 ...
   Instead, I save part of the work I do at each length and reuse it in the next.
   TODO: Figure 7
   The rule that I apply is that a solution consists of a most profitable cycle of given length l.
   TODO: Rule
V: I see, and do you have a program I can try?
R: Yes, I have the following C implementation.
   TODO: Figure 8
   The implementation ranks in the fastest 10 solutions to the problem!
V: Wow! I see other people on the Internet saying that you can solve this problem with Floyd-Warshall.
   Why did you not solve this with Floyd-Warshall?
R: I did not use Floyd-Warshall because you can't solve this problem with Floyd-Warshall.
   A recurring solution on the Internet resembles Floyd-Warshall, but does not correspond to Floyd-Warshall.
   My solution is actually more similar to the Slow All Pairs Shortest Paths in [Introduction to Algorithms].

   The SAPSP algorithm in Figure 9 is similar to my algorithm because TODO.
   TODO: Figure 9, SAPSP

   TODO: Figure 10, FW
   Floyd-Warshall considers intermediate nodes of solutions.
   F.W. considers these nodes one by one applying this rule.
   TODO: Rule
   The iteration on intermediate nodes corresponds to the iteration on m and k in SAPSP.

   When you look at solutions by [A, B, C], they resemble Floyd-Warshall, but in fact they are closer to SAPSP.
   As an example solution take [Prajogo Tio].
   His solution iterates over length `s` and then over `k`.
   Then the candidate benefit is `benefit[s][i][k] * benefit[0][k][j] = benefit[s][i][k] * rate[k][j]`.
   So the rule he applies considers second-to-last vertex as opposed to an intermediate vertex.

V: Is there any other related work?
R: Yes, there is one illustrating algorithm by [Robert Tarjan].
   His algorithm enumerates the simple cycles of graphs.
   TODO: Explain

V: That's very illustrative, thank you!
R: Welcome! If you have any questions, ask in the comments section!